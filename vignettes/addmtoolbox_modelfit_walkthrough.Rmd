---
title: "addmtoolbox: modelfit walkthrough"
author: "Alexander Fengler"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{addmtoolbox: modelfit walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

### Intro

This vignette illustrates the process of fitting (attentional) drift diffusion models to experimental choice and reaction time data (and fixation data). We are going to walk through a model fit that is done *by unique experiment condition* using only the functionality provided by the ***addmtoolbox*** package in ***R***.

As example data we are goint to use the two data frames that come supplied by the package: 

1. `addm_data_choice` 
2. `addm_data_eye`

### Load Environment

Before starting lets load the necessary environment for working with the ***addmtoolbox***.

```{r, message=FALSE, warning=FALSE}
library("addmtoolbox")
```

The package is selfcontained in that it should load all dependencies correctly, and you are good to go now. <br><br><br> 

# Data Preparation

## The Data Frames

Lets first have a quick look at the content of the two data frames that are supplied with the package.

### Choice Data

```{r, results='hide'}
# Lets look at the choice data 
head(addm_data_choice)
```

```{r, results = "asis", echo=FALSE}
pander::pandoc.table(head(addm_data_choice))
```
We can see that `addm_data_choice` has **five** columns. 

- **id** which provides a unique key per observed trial
- **v1** providing the valuation of the left item on the screen
- **v2** providing the valuation of the right item on the screen
- **decision** providing the decision taken in a specific trial (1 = left, 2 = right)
- **rt** the reaction time in a given trial

### Fixation Data

```{r, results='hide'}
  # Lets look at the choice data 
  head(addm_data_eye)
```

```{r, results = "asis", echo=FALSE}
  pander::pandoc.table(head(addm_data_eye))
```

We can see that `addm_data_eye` has **four** columns.

- **fixloc** the fixation location of a given fixation (coded as referring to item attended)
- **fixdur** the duration of a given fixation
- **fixnr** the within trial number of a fixation
- **id** a unique trial identifier that **importantly** matches the id of `addm_data_choice`

## Pre Processing 

The two **data.frames** supplied in the ***addmtoolbox*** package serve as an illustration of the structure that is expected for the package to be conveniently usable.

Once our data is in shape we can continue to use the `addm_dataprep()` function, like so:

```{r, results='hide'}
 our.dat = addm_dataprep(choice.dat = addm_data_choice,
                         eye.dat = addm_data_eye,
                         timestep = 10,
                         rtbinsize = 100,
                         fit.type = 'condition')  
```

Lets quickly go through the arguments that need to be supplied to `addm_dataprep()`:    

- `choice.dat` and `eye.dat` refer trivially to two **data.frames** (**data.tables**) in the exact shape as our example **data.frames**.      
- `timestep` refers to the size of timesteps that you would like to apply in your model fit (in milliseconds). We need to supply this for our data preparation, because fixation times and reaction times will be rounded according to the timestep-size applied for model simulations.      
- `rtbinsize` is needed to bin our reaction-time data (in milliseconds). `addm_dataprep()` will take over this binning for you and makes sure the data is in a format that these bins will be consistently applied for the rest of the modelling process.       
- Lastly, we need to supply a `fit.type`. Two fit types are currently implemented. `"condition"` and `"trial"` which refer simply to fitting of the model by trial, or by unique trial conditions. Dependent on what you supply here, the `addm_dataprep()` will return different output.   

For `fit.type = "condition"` the return value is a list of two elements.     

1. **conditions.dat**
2. **choice.dat**    

For `fit.type ="trial"` the return value is a list of two elements.    

1. **choice.dat**
2. **eye.dat**    

When **fitting by condition**, the model will assume that you are providing a fixation model yourself, and therefore does not need a separate eyetracking dataframe. Therefore we have no element for eyetracking data in the returned list    

When **fitting by trial**, the model needs empirical eyetracking data by trial, however a data.frame providing information about unique conditions is obsolete. Therefore we have a return element for eyetracking data, but none for conditions. 

Lets look at the output that we have generated with out call to `addm_dataprep()`:

```{r, echo=FALSE}
 our.dat
```

**Note**, that the id variable has changed from the one we originally supplied, to an identifier for unique trial conditions. A simple rule is applied here. The values that appear in every trial display are simply concatenated as a string and separated by "_". 

***Important***
---------

`addm_dataprep()` expects you to supply an id-variable that is a unique identifier of each trial for each subject (that means that trial 1 for subject 1 has a different key than trial 1 for subject 2). Note, that row.numbers are not sufficient, because **consistency** is demanded between ***trial-identifiers of the choice data.frame*** and ***trial-identifiers of the eye data.frame***.    

When you choose to fit by **condition**, it is important to note that `addm_dataprep()` is actually ***changing the trial-identifiers for you into condition identifiers***. STILL, `addm_dataprep()` expects you to supply the data with identifiers by trial first.

# Fitting the model


## The `addm_fit_grid()` function
Now that our data is prepared for usage with the main functions of the ***addmtoolbox** package, we can call the `addm_fit_grid()` function. This function has quite some parameters, and you find detailed information what each one stands for in the function/pckage documentation. Lets look at the default setting of all parameters below to get an overview.

```{r, eval=FALSE}
addm_fit_grid = function(conditions.dat = data.table(v1 = 0, v2 = 0, id = 0),
                         eye.dat = data.table(fixloc = 0,fixnr = 1, fixdur= 0, id = 0),
                         choice.dat = data.table(v1 = 0,v2 = 0, rt = 0, decision = 0, id = 0),
                         drifts = seq(0,0.002,0.0005),
                         thetas = seq(0.0,1,0.2),
                         sds = seq(0.05,0.15,0.025),
                         non.decision.times = 0,
                         timestep = 10,
                         nr.reps = 2000,
                         model.type = 'standard',
                         output.type = 'fit',
                         fit.type = 'condition',
                         fixation.model = 'fixedpath',
                         allow.fine.grid = 0,
                         log.file = "defaultlog.txt",
                         parallel = 1)
```


To highlight a few of the non-obvious options;

1. `model.type` which defaults to **"standard"**, lets you choose **"memnoise"** as an alternative. This is a version of the model which, given bigger set sizes than 2, lets you scale down/up noise and evidence accumulation separately for seen and unseen items. 

2. `fixation.model` is important when fitting by condition. I supply two simple fixation models with the package which are specific for the two item version for now. `addm2_fixation_model_fixedpath()` a model that spits out exactly the same fixation pathway everytime it is called (fixation duration of 400ms), which you utilize when entering **"fixedpath"** (the default). `addm2_fixation_model_random()` a model that randomly changes the starting sequence (either locations 1 then 2 or location 2 then 1), which you utilize when entering **"random"**. Most importantly, `fixation.model` can be initialized as **"user"**. This allows you to supply your own fixation model, which will be called to fill in a fixation location and a fixation duration vector at the beginning of each simulation run. You will have to supply your fixation model as a function with the name `user_fixation_model()` so that the package knows where to find it when running. 

3. `parallel` is initialized as **1**, which means that the function runs on all cores that your local system has. Supply **0** to use only one core. 

4. `allow.fine.grid` tells the grid search procedure whether the maximum likelihood found with during the coarse grid search (using all parameter combinations that can be formed from the possible parameter values you supplied) should be taken as the centerpoint of a new, finer grid search in the near neighboorhood of these parameter combination. **0** if you don't want this behavior.

5. `log.file` is where the outcome list will be stored as a file. If you don't supply a name, it will still store it under **"defualtlog.txt"**, so you will not loose your data. This file however, will be overwritten when you start a new grid search.

## Let's do it once



